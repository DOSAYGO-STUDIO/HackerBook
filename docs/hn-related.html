<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HN Backlinks - HackerBook</title>
  <meta name="description" content="Discover which Hacker News stories are most linked from comments. Find the posts with the highest link reputation.">
  <meta property="og:title" content="HN Backlinks - HackerBook">
  <meta property="og:description" content="Discover which Hacker News stories are most linked from comments. Find the posts with the highest link reputation.">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="HN Backlinks - HackerBook">
  <meta name="twitter:description" content="Discover which Hacker News stories are most linked from comments.">
  <link rel="icon" type="image/png" href="assets/msie2-2.png">
  <style>
    body { margin: 0; font: 10pt Verdana, Geneva, sans-serif; background: #f6f6ef; color: #000; }
    a { color: #000; text-decoration: none; }
    a:hover { text-decoration: underline; }
    #hnmain { width: 85%; margin: 8px auto; background: #f6f6ef; }
    .topbar {
      background: linear-gradient(to right,
        #ff6600 0%,
        #ff6600 20%,
        #ffef00 50%,
        #fffef0 75%,
        #ffffff 82%,
        #8b00ff 88%,
        #4400ff 90%,
        #00bfff 93%,
        #00ff00 95%,
        #ffff00 97%,
        #ff8000 98.5%,
        #ff0000 100%
      );
      padding: 6px 8px; display: flex; justify-content: space-between; gap: 8px; flex-wrap: wrap;
    }
    .topbar .left, .topbar .right { display: flex; gap: 8px; align-items: center; }
    .name { font-weight: 700; display: flex; align-items: center; gap: 4px; }
    .logo-icon { width: 18px; height: 18px; }
    .box { background: #f6f6ef; border: 0; }
    body.loading { cursor: wait; }
    .loading-indicator { text-align: center; padding: 40px 0; color: #828282; font-size: 10pt; }
    .row { margin: 0 0 12px 0; }
    .title { font-size: 10pt; }
    .titleline { display: inline; }
    .sub { color: #828282; font-size: 8.5pt; margin-top: 2px; }
    .sitebit { color: #828282; font-size: 8.5pt; }
    .sitestr { color: #828282; }
    .sublink { color: #828282; }
    .pager { margin: 14px 0 20px 0; color: #828282; }
    .pager a { color: #000; }
    .timeline { position: relative; padding-left: 26px; margin-top: 4px; }
    .timeline:before {
      content: "";
      position: absolute;
      left: 10px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #d7d7d7;
    }
    .timeline-day { position: relative; margin: 0 0 14px 0; }
    .timeline-day-label {
      display: inline-block;
      position: relative;
      margin: 0 0 6px 0;
      padding: 2px 8px;
      border: 1px solid #ddd;
      background: #fff9e6;
      color: #444;
      font-size: 8.5pt;
      border-radius: 10px;
    }
    .timeline-day-label:before {
      content: "";
      position: absolute;
      left: -22px;
      top: 50%;
      width: 8px;
      height: 8px;
      margin-top: -4px;
      border-radius: 50%;
      background: #ff6600;
      border: 1px solid #c84d00;
    }
    .timeline-items { margin-left: 6px; }
    .timeline-item { margin: 0 0 10px 0; }
    .num { color: #828282; margin-right: 6px; font-size: 8.5pt; }
    .ranknum { color: #828282; margin-right: 4px; font-size: 8.5pt; }
    .mono { font-family: Menlo, Monaco, Consolas, monospace; }
    .hint { color: #666; font-size: 8.5pt; }
    #snapshot { color: #000; }
    #loading-status { color: #fff; font-size: 8pt; font-family: ui-monospace, Menlo, Consolas, monospace; margin-left: 8px; }
    #top-sort, #top-years { font: 8.5pt Verdana, Geneva, sans-serif; }
    .years-wrap { position: relative; display: inline-block; }
    #top-years {
      height: 20px;
      line-height: 20px;
      text-align: center;
      padding-top: 2px;
      width: 11ch;
    }
    #top-years.expanded {
      position: absolute;
      top: 0;
      left: 0;
      height: auto;
      width: auto;
      min-width: 11ch;
      z-index: 100;
      background: #fff;
      border: 1px solid #999;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    #top-years-clear { font: 8.5pt Verdana, Geneva, sans-serif; height: 20px; }
    /* Mobile: larger tap targets */
    @media (max-width: 768px) {
      .topbar { padding: 8px; }
      .topbar .left { flex-wrap: wrap; gap: 6px; }
      #top-sort, #top-years, #top-years-clear {
        font-size: 10pt;
        height: 32px;
        line-height: 32px;
        padding: 0 8px;
        min-height: 44px; /* iOS recommended tap target */
      }
      #top-years { width: 9ch; }
      #top-years-clear { min-width: 44px; }
      .row { padding: 4px 0; }
      .title, .sub { padding: 2px 0; }
      a { padding: 4px 0; display: inline-block; }
    }
    .hr { border-top: 1px solid #ddd; margin: 10px 0; }
    .topbar { margin-bottom: 10px; }
    .box { padding-top: 10px; }
    .footer { text-align: center; margin: 30px 0 20px 0; padding-top: 14px; border-top: 2px solid #ff6600; color: #666; font-size: 8.5pt; }
    .footer .sep { color: #999; margin: 0 6px; }
  </style>
  <script src="jswasm/sqlite3.js"></script>
</head>
<body class="loading">
  <div id="hnmain">
    <div class="topbar">
      <div class="left">
        <a class="name" href="hn-related.html"><img src="assets/msie2-2.png" alt="" class="logo-icon">Hacker Backlinks</a>
        <span>|</span>
        <select id="top-sort">
          <option value="comments">most comments</option>
          <option value="points">most story points</option>
          <option value="discussions">most discussions</option>
          <option value="linked">most linked</option>
          <option value="pure_recent">most recent</option>
        </select>
        <span class="years-wrap"><select id="top-years" size="1" multiple title="Filter by year (Cmd/Ctrl-click for multi-select)"></select></span>
        <button id="top-years-clear" type="button">clear</button>
      </div>
      <div class="right">
        <span id="snapshot" class="hint"></span>
        <span id="loading-status"></span>
      </div>
    </div>
    <div id="content" class="box"><div class="loading-indicator">Loading...</div></div>
    <div class="footer">
      <span id="footer-meta" class="hint">Backlink clusters: 0.</span>
      <span class="sep">|</span>
      <a href="https://github.com/crisdosyago">Made by Cris</a>
      <span class="sep">|</span>
      <a href="https://news.ycombinator.com">Visit HN</a>
    </div>
  </div>

  <script>
  (() => {
    const PAGE_SIZE = 30;
    const PATHS = {
      manifest: 'static-related-manifest.json.gz',
      top: 'related-top.json.gz',
      shards: 'static-related-shards/'
    };

    const contentEl = document.getElementById('content');
    const footerMetaEl = document.getElementById('footer-meta');
    const snapshotEl = document.getElementById('snapshot');
    const loadingStatusEl = document.getElementById('loading-status');
    const topSortEl = document.getElementById('top-sort');
    const topYearsEl = document.getElementById('top-years');
    const topYearsClearEl = document.getElementById('top-years-clear');

    let sqlite3 = null;
    let manifest = null;
    let topIndex = null;
    const shardCache = new Map();
    const topSortCache = new Map();

    function qs() { return new URLSearchParams(location.search); }
    function esc(s) {
      return String(s == null ? '' : s)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }
    function fmtNum(n) { return Number(n || 0).toLocaleString('en-US'); }
    function fmtTime(ts) {
      if (!ts) return '';
      try {
        return new Date(ts * 1000).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
      } catch {
        return '';
      }
    }
    function dayBucket(ts) {
      const n = Number(ts || 0);
      if (!Number.isFinite(n) || n <= 0) return 0;
      return Math.floor(n / 86400);
    }
    function yearFromTs(ts) {
      const n = Number(ts || 0);
      if (!Number.isFinite(n) || n <= 0) return null;
      try {
        return new Date(n * 1000).getUTCFullYear();
      } catch {
        return null;
      }
    }
    function dayKey(ts) {
      if (!ts) return 'Unknown date';
      try {
        return new Date(ts * 1000).toISOString().slice(0, 10);
      } catch {
        return 'Unknown date';
      }
    }
    function fmtDayLabel(dayStr) {
      if (!dayStr || dayStr === 'Unknown date') return dayStr || 'Unknown date';
      try {
        const d = new Date(`${dayStr}T00:00:00Z`);
        return d.toLocaleDateString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });
      } catch {
        return dayStr;
      }
    }
    const HACKERBOOK_BASE = 'https://hackerbook.dosaygo.com';
    function storyUrl(id) { return `${HACKERBOOK_BASE}/index.html?view=item&id=${encodeURIComponent(id)}`; }
    function hnDiscussionUrl(id) { return `https://news.ycombinator.com/item?id=${encodeURIComponent(id)}`; }
    function hnFromUrl(host) { return `https://hn.algolia.com/?dateRange=all&page=0&prefix=false&query=${encodeURIComponent(host)}&sort=byDate&type=story`; }
    function userUrl(by) { return `${HACKERBOOK_BASE}/index.html?view=user&id=${encodeURIComponent(by)}`; }
    function hostFromUrl(url) {
      if (!url) return '';
      try { return new URL(url).host.replace(/^www\./i, ''); } catch { return ''; }
    }
    function siteTailHtml(url) {
      const host = hostFromUrl(url);
      if (!host) return '';
      return ` <span class="sitebit comhead">(<a href="${hnFromUrl(host)}" target="_blank" rel="noopener"><span class="sitestr">${esc(host)}</span></a>)</span>`;
    }
    function normalizeSort(v) {
      const s = String(v || 'comments').toLowerCase();
      if (s === 'comments' || s === 'points' || s === 'discussions' || s === 'linked' || s === 'pure_recent') return s;
      return 'comments';
    }
    function parseYearsParam(v) {
      const set = new Set();
      const raw = String(v || '').trim();
      if (!raw) return set;
      for (const part of raw.split(',')) {
        const y = Number(part.trim());
        if (Number.isFinite(y) && y >= 2006 && y <= 2100) set.add(y);
      }
      return set;
    }
    function yearsParamFromSet(yearSet) {
      if (!yearSet || !yearSet.size) return '';
      return [...yearSet].sort((a, b) => b - a).join(',');
    }
    function yearsFromRow(r) {
      const out = new Set();
      const raw = String((r && r.years_csv) || '').trim();
      if (raw) {
        for (const part of raw.split(',')) {
          const y = Number(part.trim());
          if (Number.isFinite(y) && y >= 2006 && y <= 2100) out.add(y);
        }
      }
      if (!out.size) {
        const y = yearFromTs(r && r.time);
        if (y != null) out.add(y);
      }
      return out;
    }
    function buildYearOptions(rows, selectedYears) {
      if (!topYearsEl) return;
      const years = new Set();
      for (const r of (rows || [])) {
        for (const y of yearsFromRow(r)) years.add(y);
      }
      const sorted = [...years].sort((a, b) => b - a);
      topYearsEl.innerHTML = '';
      for (const y of sorted) {
        const opt = document.createElement('option');
        opt.value = String(y);
        opt.textContent = String(y);
        if (selectedYears && selectedYears.has(y)) opt.selected = true;
        topYearsEl.appendChild(opt);
      }
    }
    function selectedYearsFromControl() {
      const set = new Set();
      if (!topYearsEl) return set;
      for (const opt of topYearsEl.selectedOptions || []) {
        const y = Number(opt.value);
        if (Number.isFinite(y)) set.add(y);
      }
      return set;
    }
    function setYearsMenuOpen(open) {
      if (!topYearsEl) return;
      if (open) {
        const n = Math.max(4, Math.min(14, topYearsEl.options.length || 4));
        topYearsEl.size = n;
        topYearsEl.classList.add('expanded');
      } else {
        topYearsEl.size = 1;
        topYearsEl.classList.remove('expanded');
      }
    }
    function applyYearFilter(rows, yearSet) {
      if (!yearSet || yearSet.size === 0) return rows;
      return rows.filter((r) => {
        const ys = yearsFromRow(r);
        for (const y of ys) {
          if (yearSet.has(y)) return true;
        }
        return false;
      });
    }
    function sortTopRows(rows, sortKey) {
      const sort = normalizeSort(sortKey);
      if (topSortCache.has(sort)) return topSortCache.get(sort);
      const out = rows.slice();
      if (sort === 'comments') {
        out.sort((a, b) =>
          (Number(b.comment_count || 0) - Number(a.comment_count || 0)) ||
          (Number(b.story_points_sum || 0) - Number(a.story_points_sum || 0)) ||
          (Number(b.time || 0) - Number(a.time || 0)) ||
          (Number(a.rank || 0) - Number(b.rank || 0))
        );
      } else if (sort === 'points') {
        out.sort((a, b) =>
          (Number(b.story_points_sum || 0) - Number(a.story_points_sum || 0)) ||
          (Number(b.score || 0) - Number(a.score || 0)) ||
          (Number(b.time || 0) - Number(a.time || 0)) ||
          (Number(a.rank || 0) - Number(b.rank || 0))
        );
      } else if (sort === 'discussions') {
        out.sort((a, b) =>
          (Number(b.member_count || 0) - Number(a.member_count || 0)) ||
          (Number(b.time || 0) - Number(a.time || 0)) ||
          (Number(b.story_points_sum || 0) - Number(a.story_points_sum || 0)) ||
          (Number(a.rank || 0) - Number(b.rank || 0))
        );
      } else if (sort === 'pure_recent') {
        out.sort((a, b) =>
          (dayBucket(b.time) - dayBucket(a.time)) ||
          (Number(b.story_points_sum || 0) - Number(a.story_points_sum || 0)) ||
          (Number(b.time || 0) - Number(a.time || 0)) ||
          (Number(a.rank || 0) - Number(b.rank || 0))
        );
      } else {
        out.sort((a, b) =>
          (Number(b.comment_count || 0) - Number(a.comment_count || 0)) ||
          (Number(b.story_points_sum || 0) - Number(a.story_points_sum || 0)) ||
          (Number(b.time || 0) - Number(a.time || 0)) ||
          (Number(a.rank || 0) - Number(b.rank || 0))
        );
      }
      topSortCache.set(sort, out);
      return out;
    }

    async function fetchBytes(url) {
      const r = await fetch(url, { cache: 'no-cache' });
      if (!r.ok) throw new Error(`Fetch failed ${r.status}: ${url}`);
      return new Uint8Array(await r.arrayBuffer());
    }

    async function maybeGunzip(u8) {
      if (u8.length >= 2 && u8[0] === 0x1f && u8[1] === 0x8b) {
        if (typeof DecompressionStream !== 'undefined') {
          const ds = new DecompressionStream('gzip');
          const stream = new Response(u8).body.pipeThrough(ds);
          const buf = await new Response(stream).arrayBuffer();
          return new Uint8Array(buf);
        }
        throw new Error('This browser does not support DecompressionStream.');
      }
      return u8;
    }

    async function fetchJsonMaybeGzip(url) {
      const u8 = await fetchBytes(url);
      const raw = await maybeGunzip(u8);
      return JSON.parse(new TextDecoder('utf-8').decode(raw));
    }

    function sqlAll(db, sql, bind = []) {
      return db.exec({ sql, bind, rowMode: 'object', returnValue: 'resultRows' }) || [];
    }
    function sqlOne(db, sql, bind = []) {
      const rows = sqlAll(db, sql, bind);
      return rows[0] || null;
    }

    function shardRecForRank(rank) {
      const x = Number(rank);
      for (const s of manifest.shards || []) {
        if (x >= Number(s.rank_lo) && x <= Number(s.rank_hi)) return s;
      }
      return null;
    }

    async function loadShardBySid(sid) {
      if (shardCache.has(sid)) return shardCache.get(sid);
      const rec = (manifest.shards || []).find((s) => Number(s.sid) === Number(sid));
      if (!rec) throw new Error(`Missing shard sid=${sid}`);
      const u8 = await fetchBytes(PATHS.shards + rec.file);
      const raw = await maybeGunzip(u8);
      const p = sqlite3.wasm.allocFromTypedArray(raw);
      const db = new sqlite3.oo1.DB();
      sqlite3.capi.sqlite3_deserialize(
        db.pointer,
        'main',
        p,
        raw.byteLength,
        raw.byteLength,
        sqlite3.capi.SQLITE_DESERIALIZE_FREEONCLOSE
      );
      shardCache.set(sid, db);
      return db;
    }

    function renderPager(baseParams, page, hasPrev, hasNext) {
      const prev = hasPrev
        ? `<a href="?${new URLSearchParams({ ...baseParams, p: String(page - 1) }).toString()}">prev</a>`
        : 'prev';
      const next = hasNext
        ? `<a href="?${new URLSearchParams({ ...baseParams, p: String(page + 1) }).toString()}">next</a>`
        : 'next';
      return `<div class="pager">${prev} | page ${page} | ${next}</div>`;
    }

    async function renderBacklinks(page) {
      const backlinks = topIndex.backlinks || [];
      const total = backlinks.length;
      const offset = (page - 1) * PAGE_SIZE;
      const pageRows = backlinks.slice(offset, offset + PAGE_SIZE);
      const hasPrev = page > 1;
      const hasNext = offset + PAGE_SIZE < total;

      let html = ``;
      for (let i = 0; i < pageRows.length; i += 1) {
        const r = pageRows[i];
        const rank = offset + i + 1;
        const hnHref = hnDiscussionUrl(r.story_id);
        const siteTail = siteTailHtml(r.url);
        html += `
          <div class="row">
            <div class="title"><span class="ranknum">${rank}.</span> <span class="titleline"><a href="${hnHref}" target="_blank" rel="noopener">${esc(r.title || '[untitled]')}</a>${siteTail}</span></div>
            <div class="sub">
              by ${r.by ? `<a href="${userUrl(r.by)}">${esc(r.by)}</a>` : '[unknown]'}
              | ${fmtNum(r.score || 0)} points
              | ${fmtTime(r.time)}
              | <a class="sublink" href="${hnHref}" target="_blank" rel="noopener">${fmtNum(r.incoming_link_count)} backlinks</a>
            </div>
          </div>
        `;
      }
      html += renderPager({ sort: 'linked' }, page, hasPrev, hasNext);
      contentEl.innerHTML = html;
      if (topSortEl) topSortEl.value = 'linked';
      if (topYearsEl) {
        for (const opt of topYearsEl.options) opt.selected = false;
      }
      if (footerMetaEl) footerMetaEl.textContent = `Stories with backlinks: ${fmtNum(total)}.`;
    }

    async function renderTopList(page, sortKey, yearSet) {
      const sort = normalizeSort(sortKey);
      if (sort === 'linked') {
        return renderBacklinks(page);
      }
      const rows = applyYearFilter(sortTopRows(topIndex.rows || [], sort), yearSet);
      const total = rows.length;
      const offset = (page - 1) * PAGE_SIZE;
      const pageRows = rows.slice(offset, offset + PAGE_SIZE);
      const hasPrev = page > 1;
      const hasNext = offset + PAGE_SIZE < total;
      const yearsParam = yearsParamFromSet(yearSet);

      // If year filter active, load best representative from each cluster for those years.
      let yearReps = new Map(); // component_id -> { title, by, time, score, url, story_id, memberCount }
      if (yearSet.size > 0 && pageRows.length > 0) {
        void 0 // statusEl.textContent = `Loading year-filtered representatives...`;
        const yearsArr = [...yearSet];
        const yearPlaceholders = yearsArr.map(() => '?').join(',');

        // Group by shard.
        const cidsByShard = new Map();
        for (const r of pageRows) {
          const shardRec = shardRecForRank(r.rank);
          if (!shardRec) continue;
          if (!cidsByShard.has(shardRec.sid)) cidsByShard.set(shardRec.sid, []);
          cidsByShard.get(shardRec.sid).push(r.component_id);
        }

        const shardIds = [...cidsByShard.keys()];
        let loadedShards = 0;
        for (const [sid, cids] of cidsByShard.entries()) {
          try {
            if (loadingStatusEl) loadingStatusEl.textContent = `shard ${++loadedShards}/${shardIds.length}`;
            const db = await loadShardBySid(sid);
            for (const cid of cids) {
              // Find best story from selected years (highest score, most recent).
              const yearMembers = sqlAll(db, `
                SELECT story_id, title, by, time, score, url
                FROM component_members
                WHERE component_id = ?
                  AND CAST(strftime('%Y', COALESCE(time, 0), 'unixepoch') AS INTEGER) IN (${yearPlaceholders})
                ORDER BY COALESCE(score, 0) DESC, COALESCE(time, 0) DESC
                LIMIT 1
              `, [cid, ...yearsArr]);
              if (yearMembers.length > 0) {
                const m = yearMembers[0];
                // Also count members in those years.
                const countRow = sqlOne(db, `
                  SELECT COUNT(*) as cnt
                  FROM component_members
                  WHERE component_id = ?
                    AND CAST(strftime('%Y', COALESCE(time, 0), 'unixepoch') AS INTEGER) IN (${yearPlaceholders})
                `, [cid, ...yearsArr]);
                yearReps.set(cid, {
                  story_id: m.story_id,
                  title: m.title,
                  by: m.by,
                  time: m.time,
                  score: m.score,
                  url: m.url,
                  memberCount: countRow?.cnt || 1
                });
              }
            }
          } catch (err) {
            console.warn(`Failed to load year reps from shard ${sid}:`, err);
          }
        }
        if (loadingStatusEl) loadingStatusEl.textContent = '';
      }

      let html = ``;
      for (let i = 0; i < pageRows.length; i += 1) {
        const r = pageRows[i];
        const rank = offset + i + 1;
        const clusterParams = new URLSearchParams({ cid: String(r.component_id), sort });
        if (yearsParam) clusterParams.set('years', yearsParam);
        const clusterHref = `?${clusterParams.toString()}`;

        // Use year-filtered representative if available.
        const rep = yearReps.get(r.component_id);
        const displayTitle = rep ? rep.title : r.title;
        const displayBy = rep ? rep.by : r.by;
        const displayTime = rep ? rep.time : r.time;
        const displayScore = rep ? rep.score : r.score;
        const displayUrl = rep ? rep.url : r.root_url;
        const displayStoryId = rep ? rep.story_id : r.root_story_id;
        const displayMemberCount = rep ? rep.memberCount : r.member_count;

        const clusterPoints = Math.round(Number(r.story_points_sum != null ? r.story_points_sum : (displayScore || 0)));
        const siteTail = siteTailHtml(displayUrl);
        html += `
          <div class="row">
            <div class="title"><span class="ranknum">${rank}.</span> <span class="titleline"><a href="${clusterHref}">${esc(displayTitle || '[untitled]')}</a>${siteTail}</span></div>
            <div class="sub">
              by ${displayBy ? `<a href="${userUrl(displayBy)}">${esc(displayBy)}</a>` : '[unknown]'}
              | ${fmtNum(clusterPoints)} points
              | ${fmtTime(displayTime)}
              | <a class="sublink" href="${clusterHref}">${fmtNum(displayMemberCount)} discussions (${fmtNum(r.comment_count)} comments)</a>
            </div>
          </div>
        `;
      }
      html += renderPager(yearsParam ? { sort, years: yearsParam } : { sort }, page, hasPrev, hasNext);
      contentEl.innerHTML = html;
      if (topSortEl) topSortEl.value = sort;
      if (topYearsEl) {
        for (const opt of topYearsEl.options) opt.selected = yearSet.has(Number(opt.value));
      }
      if (footerMetaEl) footerMetaEl.textContent = `Backlink clusters: ${fmtNum(total)}.`;
      void 0 // statusEl.textContent = `Loaded ${fmtNum(pageRows.length)} rows (page ${page}).`;
    }

    async function renderCluster(componentId, page, sortKey = 'comments', yearSet = new Set()) {
      const sort = normalizeSort(sortKey);
      const cid = Number(componentId);
      const yearsParam = yearsParamFromSet(yearSet);
      const rootRow = (topIndex.rows || []).find((r) => Number(r.component_id) === cid);
      if (!rootRow) {
        contentEl.innerHTML = `<div class="row">Cluster not found: <span class="mono">${esc(componentId)}</span></div>`;
        void 0 // statusEl.textContent = 'Cluster not found.';
        return;
      }
      const shardRec = shardRecForRank(rootRow.rank);
      if (!shardRec) {
        contentEl.innerHTML = `<div class="row">No shard found for cluster rank ${esc(rootRow.rank)}.</div>`;
        void 0 // statusEl.textContent = 'Missing shard.';
        return;
      }

      void 0 // statusEl.textContent = `Loading cluster ${cid} from shard ${shardRec.sid}...`;
      if (loadingStatusEl) loadingStatusEl.textContent = `shard ${shardRec.sid}`;
      const db = await loadShardBySid(shardRec.sid);
      if (loadingStatusEl) loadingStatusEl.textContent = '';

      let comp = null;
      try {
        comp = sqlOne(db, `
          SELECT component_id, root_story_id, member_count, edge_count, rank_score, latest_time, story_points_sum, comment_count, root_title, root_by, root_time, root_score, root_url
          FROM components
          WHERE component_id=?
          LIMIT 1
        `, [cid]);
      } catch {
        // Backward compatibility with older related shards.
        comp = sqlOne(db, `
          SELECT component_id, root_story_id, member_count, edge_count, rank_score, latest_time, root_title, root_by, root_time, root_score
          FROM components
          WHERE component_id=?
          LIMIT 1
        `, [cid]);
        if (comp) {
          comp.story_points_sum = null;
          comp.comment_count = null;
          comp.root_url = null;
        }
      }
      if (!comp) {
        contentEl.innerHTML = `<div class="row">Cluster ${esc(componentId)} not present in shard ${esc(shardRec.sid)}.</div>`;
        void 0 // statusEl.textContent = 'Cluster missing in shard.';
        return;
      }

      // Load all members, then filter by year if needed.
      let allMembers = [];
      try {
        allMembers = sqlAll(db, `
          SELECT story_id, rel_score, title, by, time, score, url
          FROM component_members
          WHERE component_id=?
          ORDER BY date(COALESCE(time,0), 'unixepoch') DESC, COALESCE(score,0) DESC, COALESCE(time,0) DESC, story_id DESC
        `, [cid]);
      } catch {
        allMembers = sqlAll(db, `
          SELECT story_id, rel_score, title, by, time, score
          FROM component_members
          WHERE component_id=?
          ORDER BY date(COALESCE(time,0), 'unixepoch') DESC, COALESCE(score,0) DESC, COALESCE(time,0) DESC, story_id DESC
        `, [cid]).map((r) => ({ ...r, url: null }));
      }

      // Filter by year if selected.
      let filteredMembers = allMembers;
      if (yearSet.size > 0) {
        filteredMembers = allMembers.filter((m) => {
          const y = yearFromTs(m.time);
          return y != null && yearSet.has(y);
        });
      }

      const total = filteredMembers.length;
      const offset = (page - 1) * PAGE_SIZE;
      const members = filteredMembers.slice(offset, offset + PAGE_SIZE);
      const hasPrev = page > 1;
      const hasNext = offset + PAGE_SIZE < total;
      const backQs = new URLSearchParams({ sort });
      if (yearsParam) backQs.set('years', yearsParam);
      const backHref = `hn-related.html?${backQs.toString()}`;

      let html = `
        <div class="row">
          <div class="title"><a href="${backHref}">‚Üê back to backlinks</a></div>
          <div class="hr"></div>
          <div class="title"><b>${esc(comp.root_title || '[untitled]')}</b>${siteTailHtml(comp.root_url)}</div>
          <div class="sub">
            root story: <a href="${hnDiscussionUrl(comp.root_story_id)}" target="_blank" rel="noopener">${esc(comp.root_story_id)}</a>
            (<a href="${storyUrl(comp.root_story_id)}">hackerbook</a>)
            | by ${comp.root_by ? `<a href="${userUrl(comp.root_by)}">${esc(comp.root_by)}</a>` : '[unknown]'}
            | ${fmtNum(comp.root_score)} points
            | ${fmtTime(comp.root_time)}
          </div>
          <div class="sub">
            ${yearSet.size > 0
              ? `showing: ${fmtNum(total)} of ${fmtNum(comp.member_count)} discussions (filtered by ${[...yearSet].sort((a,b)=>b-a).join(', ')})`
              : `members: ${fmtNum(comp.member_count)} discussions (${fmtNum(comp.comment_count)} comments) | links: ${fmtNum(comp.edge_count)}`}
          </div>
        </div>
        <div class="hr"></div>
        <div class="hint">Timeline order: newest day first; within each day highest points first.${yearSet.size > 0 ? ' Year filter active.' : ''}</div>
        <div class="timeline">
      `;
      let openDay = null;
      members.forEach((m, i) => {
        const rank = offset + i + 1;
        const dKey = dayKey(m.time);
        if (openDay !== dKey) {
          if (openDay !== null) html += `</div></div>`;
          openDay = dKey;
          html += `
            <div class="timeline-day">
              <div class="timeline-day-label">${esc(fmtDayLabel(dKey))}</div>
              <div class="timeline-items">
          `;
        }
        html += `
          <div class="timeline-item">
            <div class="title"><span class="num">${rank}.</span><span class="titleline"><a href="${hnDiscussionUrl(m.story_id)}" target="_blank" rel="noopener">${esc(m.title || `[story ${m.story_id}]`)}</a>${siteTailHtml(m.url)}</span></div>
            <div class="sub">
              by ${m.by ? `<a href="${userUrl(m.by)}">${esc(m.by)}</a>` : '[unknown]'}
              | ${fmtNum(m.score)} points
              | ${fmtTime(m.time)}
              | rel ${Number(m.rel_score || 0).toFixed(3)}
              | <a href="${storyUrl(m.story_id)}">hackerbook</a>
            </div>
          </div>
        `;
      });
      if (openDay !== null) html += `</div></div>`;
      html += `</div>`;
      html += renderPager({ cid: String(cid), sort }, page, hasPrev, hasNext);

      contentEl.innerHTML = html;
      if (topSortEl) topSortEl.value = sort;
      if (topYearsEl) {
        for (const opt of topYearsEl.options) opt.selected = yearSet.has(Number(opt.value));
      }
      if (footerMetaEl) footerMetaEl.textContent = `Backlink clusters: ${fmtNum(applyYearFilter(topIndex.rows || [], yearSet).length)}.`;
      void 0 // statusEl.textContent = `Loaded cluster ${cid}, showing ${members.length}/${fmtNum(total)} members.`;
    }

    async function init() {
      try {
        sqlite3 = await window.sqlite3InitModule();
        manifest = await fetchJsonMaybeGzip(PATHS.manifest);
        topIndex = await fetchJsonMaybeGzip(PATHS.top);
        if (manifest && manifest.snapshot_time) {
          snapshotEl.textContent = `snapshot ${fmtTime(manifest.snapshot_time)}`;
        }
        buildYearOptions(topIndex.rows || [], new Set());

        const p = qs();
        const page = Math.max(1, parseInt(p.get('p') || '1', 10));
        const sort = normalizeSort(p.get('sort') || 'comments');
        const yearSet = parseYearsParam(p.get('years') || '');
        if (topYearsEl) {
          for (const opt of topYearsEl.options) opt.selected = yearSet.has(Number(opt.value));
        }
        if (topSortEl) {
          topSortEl.value = sort;
          topSortEl.addEventListener('change', () => {
            const next = normalizeSort(topSortEl.value);
            const years = yearsParamFromSet(selectedYearsFromControl());
            const q = new URLSearchParams(location.search);
            q.set('sort', next);
            if (years) q.set('years', years); else q.delete('years');
            q.set('p', '1');
            q.delete('cid');
            location.search = q.toString();
          });
        }
        if (topYearsEl) {
          let initialYearsParam = yearsParamFromSet(yearSet);
          topYearsEl.addEventListener('mousedown', (e) => {
            if (topYearsEl.size <= 1) {
              e.preventDefault();
              setYearsMenuOpen(true);
              topYearsEl.focus();
            }
          });
          topYearsEl.addEventListener('focus', () => setYearsMenuOpen(true));
          topYearsEl.addEventListener('blur', () => {
            setYearsMenuOpen(false);
            // Auto-apply on blur if selection changed.
            const newYears = yearsParamFromSet(selectedYearsFromControl());
            if (newYears !== initialYearsParam) {
              const q = new URLSearchParams(location.search);
              if (newYears) q.set('years', newYears); else q.delete('years');
              q.set('p', '1');
              q.delete('cid');
              location.search = q.toString();
            }
          });
          topYearsEl.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
              setYearsMenuOpen(false);
              topYearsEl.blur();
            }
          });
        }
        if (topYearsClearEl) {
          topYearsClearEl.addEventListener('click', () => {
            // Clear all year selections.
            if (topYearsEl) {
              for (const opt of topYearsEl.options) opt.selected = false;
            }
            const q = new URLSearchParams(location.search);
            q.delete('years');
            q.set('p', '1');
            q.delete('cid');
            location.search = q.toString();
          });
        }
        const cid = p.get('cid');
        if (cid) {
          await renderCluster(cid, page, sort, yearSet);
        } else {
          await renderTopList(page, sort, yearSet);
        }
        document.body.classList.remove('loading');
      } catch (err) {
        document.body.classList.remove('loading');
        contentEl.innerHTML = `<div class="row mono">${esc(err && err.message ? err.message : String(err))}</div>`;
      }
    }

    init();
  })();
  </script>
</body>
</html>
